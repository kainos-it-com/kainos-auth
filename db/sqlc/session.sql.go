// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: session.sql

package sqlc

import (
	"context"
	"time"
)

const countUserSessions = `-- name: CountUserSessions :one
SELECT COUNT(*) FROM "session" WHERE user_id = $1 AND expires_at > NOW()
`

func (q *Queries) CountUserSessions(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO "session" (id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at
`

type CreateSessionParams struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	IpAddress *string   `json:"ip_address"`
	UserAgent *string   `json:"user_agent"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM "session" WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at FROM "session" WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at FROM "session" WHERE token = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionWithUser = `-- name: GetSessionWithUser :one
SELECT 
    s.id, s.user_id, s.token, s.expires_at, s.ip_address, s.user_agent, s.created_at, s.updated_at,
    u.id AS user_id,
    u.name AS user_name,
    u.email AS user_email,
    u.email_verified AS user_email_verified,
    u.image AS user_image
FROM "session" s
JOIN "user" u ON s.user_id = u.id
WHERE s.token = $1 AND s.expires_at > NOW()
`

type GetSessionWithUserRow struct {
	ID                string    `json:"id"`
	UserID            string    `json:"user_id"`
	Token             string    `json:"token"`
	ExpiresAt         time.Time `json:"expires_at"`
	IpAddress         *string   `json:"ip_address"`
	UserAgent         *string   `json:"user_agent"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	UserID_2          string    `json:"user_id_2"`
	UserName          string    `json:"user_name"`
	UserEmail         string    `json:"user_email"`
	UserEmailVerified bool      `json:"user_email_verified"`
	UserImage         *string   `json:"user_image"`
}

func (q *Queries) GetSessionWithUser(ctx context.Context, token string) (GetSessionWithUserRow, error) {
	row := q.db.QueryRow(ctx, getSessionWithUser, token)
	var i GetSessionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID_2,
		&i.UserName,
		&i.UserEmail,
		&i.UserEmailVerified,
		&i.UserImage,
	)
	return i, err
}

const listActiveSessions = `-- name: ListActiveSessions :many
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at FROM "session"
WHERE user_id = $1 AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) ListActiveSessions(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.Query(ctx, listActiveSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.ExpiresAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSessions = `-- name: ListUserSessions :many
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at FROM "session"
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserSessions(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.Query(ctx, listUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.ExpiresAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeOtherSessions = `-- name: RevokeOtherSessions :exec
DELETE FROM "session" WHERE user_id = $1 AND id != $2
`

type RevokeOtherSessionsParams struct {
	UserID string `json:"user_id"`
	ID     string `json:"id"`
}

func (q *Queries) RevokeOtherSessions(ctx context.Context, arg RevokeOtherSessionsParams) error {
	_, err := q.db.Exec(ctx, revokeOtherSessions, arg.UserID, arg.ID)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
DELETE FROM "session" WHERE id = $1
`

func (q *Queries) RevokeSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, revokeSession, id)
	return err
}

const revokeSessionByToken = `-- name: RevokeSessionByToken :exec
DELETE FROM "session" WHERE token = $1
`

func (q *Queries) RevokeSessionByToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, revokeSessionByToken, token)
	return err
}

const revokeUserSessions = `-- name: RevokeUserSessions :exec
DELETE FROM "session" WHERE user_id = $1
`

func (q *Queries) RevokeUserSessions(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, revokeUserSessions, userID)
	return err
}

const updateSessionExpiry = `-- name: UpdateSessionExpiry :one
UPDATE "session"
SET expires_at = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, token, expires_at, ip_address, user_agent, created_at, updated_at
`

type UpdateSessionExpiryParams struct {
	ID        string    `json:"id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpdateSessionExpiry(ctx context.Context, arg UpdateSessionExpiryParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionExpiry, arg.ID, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
