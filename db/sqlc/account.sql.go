// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package sqlc

import (
	"context"
	"time"
)

const countUserAccounts = `-- name: CountUserAccounts :one
SELECT COUNT(*) FROM "account" WHERE user_id = $1
`

func (q *Queries) CountUserAccounts(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAccounts, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO "account" (
    id, user_id, account_id, provider_id, access_token, refresh_token,
    access_token_expires_at, refresh_token_expires_at, scope, id_token, password,
    created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())
RETURNING id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
`

type CreateAccountParams struct {
	ID                    string     `json:"id"`
	UserID                string     `json:"user_id"`
	AccountID             string     `json:"account_id"`
	ProviderID            string     `json:"provider_id"`
	AccessToken           *string    `json:"access_token"`
	RefreshToken          *string    `json:"refresh_token"`
	AccessTokenExpiresAt  *time.Time `json:"access_token_expires_at"`
	RefreshTokenExpiresAt *time.Time `json:"refresh_token_expires_at"`
	Scope                 *string    `json:"scope"`
	IDToken               *string    `json:"id_token"`
	Password              *string    `json:"password"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.ID,
		arg.UserID,
		arg.AccountID,
		arg.ProviderID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.IDToken,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM "account" WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteUserAccounts = `-- name: DeleteUserAccounts :exec
DELETE FROM "account" WHERE user_id = $1
`

func (q *Queries) DeleteUserAccounts(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteUserAccounts, userID)
	return err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at FROM "account" WHERE id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByProvider = `-- name: GetAccountByProvider :one
SELECT id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at FROM "account"
WHERE provider_id = $1 AND account_id = $2
`

type GetAccountByProviderParams struct {
	ProviderID string `json:"provider_id"`
	AccountID  string `json:"account_id"`
}

func (q *Queries) GetAccountByProvider(ctx context.Context, arg GetAccountByProviderParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByProvider, arg.ProviderID, arg.AccountID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCredentialAccount = `-- name: GetUserCredentialAccount :one
SELECT id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at FROM "account"
WHERE user_id = $1 AND provider_id = 'credential'
`

func (q *Queries) GetUserCredentialAccount(ctx context.Context, userID string) (Account, error) {
	row := q.db.QueryRow(ctx, getUserCredentialAccount, userID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkAccount = `-- name: LinkAccount :one
INSERT INTO "account" (
    id, user_id, account_id, provider_id, access_token, refresh_token,
    access_token_expires_at, refresh_token_expires_at, scope, id_token,
    created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW())
RETURNING id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
`

type LinkAccountParams struct {
	ID                    string     `json:"id"`
	UserID                string     `json:"user_id"`
	AccountID             string     `json:"account_id"`
	ProviderID            string     `json:"provider_id"`
	AccessToken           *string    `json:"access_token"`
	RefreshToken          *string    `json:"refresh_token"`
	AccessTokenExpiresAt  *time.Time `json:"access_token_expires_at"`
	RefreshTokenExpiresAt *time.Time `json:"refresh_token_expires_at"`
	Scope                 *string    `json:"scope"`
	IDToken               *string    `json:"id_token"`
}

func (q *Queries) LinkAccount(ctx context.Context, arg LinkAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, linkAccount,
		arg.ID,
		arg.UserID,
		arg.AccountID,
		arg.ProviderID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.IDToken,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserAccounts = `-- name: ListUserAccounts :many
SELECT id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at FROM "account"
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserAccounts(ctx context.Context, userID string) ([]Account, error) {
	rows, err := q.db.Query(ctx, listUserAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.ProviderID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.IDToken,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserPassword = `-- name: SetUserPassword :one
UPDATE "account"
SET password = $2, updated_at = NOW()
WHERE user_id = $1 AND provider_id = 'credential'
RETURNING id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
`

type SetUserPasswordParams struct {
	UserID   string  `json:"user_id"`
	Password *string `json:"password"`
}

func (q *Queries) SetUserPassword(ctx context.Context, arg SetUserPasswordParams) (Account, error) {
	row := q.db.QueryRow(ctx, setUserPassword, arg.UserID, arg.Password)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unlinkAccount = `-- name: UnlinkAccount :exec
DELETE FROM "account"
WHERE user_id = $1 AND provider_id = $2
`

type UnlinkAccountParams struct {
	UserID     string `json:"user_id"`
	ProviderID string `json:"provider_id"`
}

func (q *Queries) UnlinkAccount(ctx context.Context, arg UnlinkAccountParams) error {
	_, err := q.db.Exec(ctx, unlinkAccount, arg.UserID, arg.ProviderID)
	return err
}

const updateAccountPassword = `-- name: UpdateAccountPassword :one
UPDATE "account"
SET password = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
`

type UpdateAccountPasswordParams struct {
	ID       string  `json:"id"`
	Password *string `json:"password"`
}

func (q *Queries) UpdateAccountPassword(ctx context.Context, arg UpdateAccountPasswordParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountPassword, arg.ID, arg.Password)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountTokens = `-- name: UpdateAccountTokens :one
UPDATE "account"
SET access_token = $2,
    refresh_token = $3,
    access_token_expires_at = $4,
    refresh_token_expires_at = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
`

type UpdateAccountTokensParams struct {
	ID                    string     `json:"id"`
	AccessToken           *string    `json:"access_token"`
	RefreshToken          *string    `json:"refresh_token"`
	AccessTokenExpiresAt  *time.Time `json:"access_token_expires_at"`
	RefreshTokenExpiresAt *time.Time `json:"refresh_token_expires_at"`
}

func (q *Queries) UpdateAccountTokens(ctx context.Context, arg UpdateAccountTokensParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountTokens,
		arg.ID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
